---
title: 排序
---

# 排序
常用的三类排序算法：

| 算法 | 时间复杂度 |
| --- | --- |
| 冒泡、插入、选择 | `O(n2)` |
| 快排、归并 | `O(nlogn)` |
| 桶、计数、基数 | `O(n)` |

插入排序和冒泡排序的时间复杂度相同，为什么更倾向于使用插入排序算法而不是冒泡排序算法？

## 分析排序算法
### 执行效率
### 内存消耗
### 稳定性
1. 最好情况、最坏情况、平均情况时间复杂度
2. 时间复杂度的系数、常数、低阶
3. 比较次数和交换（或移动）次数
基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，在分析排序算法的执行效率的时候，
应该把比较次数和交换（或移动）次数也考虑进去。

## 冒泡排序
冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡
会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。
```go
func BubbleSort(a []int) {
	length := len(a)
	if len(a) <= 1 {
		return
	}
	for i := 0; i < length; i ++ {
		flag := false
		for j := 0; j < length - i - 1; j ++ {
			if a[j] > a[j + 1] {
				a[j], a[j + 1] = a[j + 1], a[j]
				flag = true
			}
		}
		if !flag {
			break
		}
	}
}
```

## 插入排序
一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。
