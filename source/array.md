---
title: 数组
---

# 数组
几乎每种语言都有数组这种数据类型，为什么数组的下标都是从 0 开始？

## 数组的随机访问
数组是一种线性表的数据结构，用一组连续的内存空间，来存储一组相同类型的数据。

**线性表**
线性表就是数据排程一条线一样的结构。线性表上的数据只有前后两个方向。（链表，栈，队列也是线性表结构）。

二叉树，图，堆等是**非线性表**结构。非线性表中数据不再是简单的前后关系。

**连续的内存空间和相同类型的数据**
连续的内存空间和相同类型的数据，正式因为这两个限制，才使数组可以实现随机访问。但是这两个限制也让其他的
操作变得效率低下，比如在数组中插入或删除一个值，为了保证数据的连续，就必须进行数据搬移。

例如：一个长度为 10 的 `int` 类型的数组 `a := new([10]int)`。计算机给数组 `a[10]`，分配了一块连续内存空间 `1000～1039`，
其中，内存块的首地址为 `base_address = 1000`。

计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通
过下面的寻址公式，计算出该元素存储的内存地址：
```
a[i]_address = base_address + i * data_type_size
```

`data_type_size` 表示数组中每个元素的大小。

## 数组的插入和删除
为什么说数组的插入和删除效率低？

比如一个数组的长度为 n，如果要插入一个元素在 k 位置，时间复杂度是多少?

如果在数组的末尾插入，那么不需要移动数据，在末尾加入元素即可，这时是最好时间复杂度，为 `O(1)`。如果在数组的开头插入元素，那么所有元素一次向
后移动一位，这时是最坏时间复杂度，为 `O(n)`。由于在每个位置插入的概率是一样的，那么平均时间复杂度为 `(1 + 2 + ...n)/n = O(n)`。

删除元素和插入元素差不多。如果删除数组末尾的数据，则最好情况时间复杂度为 `O(1)`；如果删除开头的数据，则最坏情况时间复杂度为 `O(n)`；平均情况
时间复杂度也为 `O(n)`。如果数组是无序的，多次删除操作可以集中在一起执行。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组
没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

### 如何避免移动数据
如果数组是有序的，那么插入元素就必须移动数据。对于无序的数组，如果要在 k 位置插入元素，为了避免移动数据，可以直接将 k 位置的原数据移动到
数据末尾，把新的元素放在 k 位置。

## 为什么数组的下标都是从 0 开始
下标就是"偏移 (offset)"，上面的例子中数组 a 的首地址是 `a[0]`，也就是偏移为 0 的位置。`a[k]` 就表示偏移 k 个 `data_type_size` 的
位置，那么 `a[k]` 内存地址为 `a[k]_address = base_address + k * data_type_size`。

但是如果数组从 1 开始，`a[k]` 内存地址就是 `a[k]_address = base_address + (k - 1) * data_type_size`，可以看出
多了一次减法运算， CPU 就多一次减法指令。对于数组这种基础数据结构，少一次操作就可以提高一点效率。

也可能是历史原因，C 语言是从 0 开始，之后的语言也都效仿了 C 语言。