---
title: 哈希算法
---

# 哈希算法
不管是“散列”还是“哈希”，英文都是 “Hash”。

哈希算法的定义和原理，基本上一句话就可以概括了。将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数
据映射之后得到的二进制值串就是**哈希值**。

实现哈希算法的要求：
- 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；
- 对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；
- 散列冲突的概率要很小；
- 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。

## 应用
### 安全加密
哈希算法最先想到的应该就是安全加密。最常用于加密的哈希算法是 MD5（MD5 Message-Digest Algorithm，MD5消息摘要算法）和 
SHA（Secure Hash Algorithm，安全散列算法）。

不管是什么哈希算法，只能尽量减少碰撞冲突的概率，理论上是没办法做到完全不冲突的。为什么这么说？

鸽巢原理（也叫抽屉原理）：它是说，如果有 10 个鸽巢，有 11 只鸽子，那肯定有 1 个鸽巢中的鸽子数量多于 1 个。

哈希算法产生的哈希值的长度是固定且有限的。比如 MD5 算法的哈希值是固定的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据，
而我们要哈希的数据是无穷的。基于鸽巢原理，如果我们对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情况。一般情况下，
**哈希值越长的哈希算法，散列冲突的概率越低**。

### 唯一标识
如果要在海量的图库中，搜索一张图是否存在，我们不能单纯地用图片的元信息（比如图片名称）来比对，因为有可能存在名称相同但图片内容不同，或者名
称不同图片内容相同的情况。该如何搜索？

比较笨的办法就是，拿要查找的图片的二进制码串与图库中所有图片的二进制码串一一比对。如果相同，则说明图片在图库中存在。但是图片越大，就越耗时。

更好的方法是给每一个图片取一个唯一标识，或者说信息摘要。比如，可以从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再
取 100 个字节，然后将这 300 个字节放到一块，通过哈希算法（比如 MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判
定图片是否在图库中，这样就可以减少很多工作量。

### 数据校验
BT 下载的原理是基于 P2P 协议的。我们从多个机器上并行下载一个 2GB 的电影，这个电影文件可能会被分割成很多文件块（比如可以分成 100 块，每
块大约 20MB）。等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了。

网络传输是不安全的，下载的文件块有可能是被宿主机器恶意修改过的，又或者下载过程中出现了错误，所以下载的文件块可能不是完整的。如果没有能力
检测这种恶意修改或者文件下载出错，就会导致最终合并后的电影无法观看，甚至导致电脑中毒。

可以通过哈希算法，对 100 个文件块分别取哈希值，并且保存在种子文件中。哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，
最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的
哈希值比对。如果不同，说明这个文件块不完整或者被篡改了。

### 散列函数
散列函数也是哈希算法的一种应用。

### 负载均衡
负载均衡算法有很多，比如轮询、随机、加权轮询等。如何在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上？

可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由
到的服务器编号。

### 数据分片
假设现在图库中有 1 亿张图片，很显然，在单台机器上构建散列表是行不通的。因为单台机器的内存有限，而 1 亿张图片构建散列表显然远远超过了单台
机器的内存上限。我们同样可以对数据进行分片，然后采用多机处理。我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。每次从图库中读取
一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列
表。当要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就
去编号 k 的机器构建的散列表中查找。

### 分布式存储
如果有海量的数据需要缓存，所以一个缓存机器肯定是不够的。于是，我们就需要将数据分布在多台机器上。

如何决定将哪个数据放到哪个机器上？我们可以借用前面数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值
就是应该存储的缓存机器编号。

但是，如果数据增多，原来的10个机器已经无法承受了，我们就需要扩容了，比如扩到11个机器，这时候麻烦就来了。因为，这里并不是简单地
加个机器就可以了。原来的数据是通过与 10 来取模的。比如 13 这个数据，存储在编号为 3 这台机器上。但是新加了一台机器中，我们对数据按
照 11 取模，原来 13 这个数据就被分配到 2 号这台机器上了。

因此，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。相当于，缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，
直接去请求数据库。这样就可能发生雪崩效应，压垮数据库。

假设我们有 k 个机器，数据的哈希值的范围是 `[0, MAX]`。我们将整个范围划分成 m 个小区间（ m 远大于 k），每个机器负责 m/k 个小区间。当有
新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数
量的均衡。



