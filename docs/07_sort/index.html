<!DOCTYPE html>
<html lang="en" dir=>

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="排序#常用的三类排序算法：
   算法 时间复杂度     冒泡、插入、选择 O(n^2)   快排、归并 O(nlogn)   桶、计数、基数 O(n)    插入排序和冒泡排序的时间复杂度相同，为什么更倾向于使用插入排序算法而不是冒泡排序算法？
分析排序算法#执行效率#排序算法执行效率的分析，可以通过几个方面来衡量：
 最好情况、最坏情况、平均情况时间复杂度 时间复杂度的系数、常数、低阶我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但 是实际的软件开发中，排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，就要把 系数、常数、低阶也考虑进来。 基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果在分析排序算法的执行效率的时候， 应该把比较次数和交换（或移动）次数也考虑进去。  内存消耗#算法的内存消耗可以通过空间复杂度来衡量，针对排序算法的空间复杂度，有一个概念，原地排序（Sorted in place），就是特指“空间复杂度” 是 O(1) 的排序算法。冒泡排序，插入排序，选择排序都是原地排序算法。
稳定性#稳定性就是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。
比如一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。
这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法； 如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。
为什么要考察排序算法的稳定性#真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个 key 来排序。 比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望 按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="排序" />
<meta property="og:description" content="排序#常用的三类排序算法：
   算法 时间复杂度     冒泡、插入、选择 O(n^2)   快排、归并 O(nlogn)   桶、计数、基数 O(n)    插入排序和冒泡排序的时间复杂度相同，为什么更倾向于使用插入排序算法而不是冒泡排序算法？
分析排序算法#执行效率#排序算法执行效率的分析，可以通过几个方面来衡量：
 最好情况、最坏情况、平均情况时间复杂度 时间复杂度的系数、常数、低阶我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但 是实际的软件开发中，排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，就要把 系数、常数、低阶也考虑进来。 基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果在分析排序算法的执行效率的时候， 应该把比较次数和交换（或移动）次数也考虑进去。  内存消耗#算法的内存消耗可以通过空间复杂度来衡量，针对排序算法的空间复杂度，有一个概念，原地排序（Sorted in place），就是特指“空间复杂度” 是 O(1) 的排序算法。冒泡排序，插入排序，选择排序都是原地排序算法。
稳定性#稳定性就是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。
比如一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。
这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法； 如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。
为什么要考察排序算法的稳定性#真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个 key 来排序。 比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望 按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://shipengqi.github.io/algorithm-learn/docs/07_sort/" />
<meta property="article:modified_time" content="2020-06-18T17:06:12+08:00" />
<title>排序 | Algorithm Learning</title>
<link rel="manifest" href="/algorithm-learn/manifest.json">
<link rel="icon" href="/algorithm-learn/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/algorithm-learn/book.min.b3215d9d1d18d9051e7fbe8f256ff80e30f41d29073b86348e230d297b771002.css" integrity="sha256-syFdnR0Y2QUef76PJW/4DjD0HSkHO4Y0jiMNKXt3EAI=">
<script defer src="/algorithm-learn/en.search.min.511cae842a1aa3c6a84d63e20bade0ff9213702b34b6fe826804dc6e1b02a9e3.js" integrity="sha256-URyuhCoao8aoTWPiC63g/5ITcCs0tv6CaATcbhsCqeM="></script>

<script defer src="/algorithm-learn/sw.min.eaff391435f87073ec5af42687d96b565bbf32cc51b0c17648cd12c7d96f6307.js" integrity="sha256-6v85FDX4cHPsWvQmh9lrVlu/MsxRsMF2SM0Sx9lvYwc="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir=>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/algorithm-learn"><span>Algorithm Learning</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>






  
<ul>
  
  <li>
    <a href="https://github.com/shipengqi/algorithm-learn" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://shipengqi.github.io/" target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
</ul>







  <p>━━━━━━━━━━━━━━━━━━━━</p>
<ul>
<li><a href="/algorithm-learn/docs/01_complex_analysis/">复杂度分析</a></li>
<li><a href="/algorithm-learn/docs/02_array/">数组</a></li>
<li><a href="/algorithm-learn/docs/03_link_list/">链表</a></li>
<li><a href="/algorithm-learn/docs/04_stack/">栈</a></li>
<li><a href="/algorithm-learn/docs/05_queue/">队列</a></li>
<li><a href="/algorithm-learn/docs/06_recursion/">递归</a></li>
<li><a href="/algorithm-learn/docs/07_sort/"class=active>排序</a></li>
<li><a href="/algorithm-learn/docs/08_linear_sort/">线性排序</a></li>
<li><a href="/algorithm-learn/docs/09_binary_search/">二分查找</a></li>
<li><a href="/algorithm-learn/docs/10_skip_list/">跳表</a></li>
<li><a href="/algorithm-learn/docs/11_hash_table/">散列表</a></li>
<li><a href="/algorithm-learn/docs/12_hash_algo/">哈希算法</a></li>
<li><a href="/algorithm-learn/docs/13_binary_tree/">二叉树</a></li>
<li><a href="/algorithm-learn/docs/14_heap/">堆</a></li>
<li><a href="/algorithm-learn/docs/15_graph/">图</a></li>
<li><a href="/algorithm-learn/docs/16_string_match_algo/">字符串匹配算法</a></li>
<li><a href="/algorithm-learn/docs/17_trie/">Trie 树</a></li>
<li><a href="/algorithm-learn/docs/18_ac/">AC 自动机</a></li>
<li><a href="/algorithm-learn/docs/19_greedy/">贪心算法</a></li>
<li><a href="/algorithm-learn/docs/20_deivide_conquer/">分治算法</a></li>
<li><a href="/algorithm-learn/docs/21_backtracking/">回溯算法</a></li>
<li><a href="/algorithm-learn/docs/22_dynamic_programming/">动态规划</a></li>
<li><a href="/algorithm-learn/docs/23_bit_map/">位图</a></li>
<li><a href="/algorithm-learn/docs/24_bmore_tree/">索引</a></li>
<li><a href="/algorithm-learn/docs/25_vector/">向量空间</a>
<!-- raw HTML omitted --></li>
</ul>










</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/algorithm-learn/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>排序</strong>

  <label for="toc-control">
    
    <img src="/algorithm-learn/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#分析排序算法">分析排序算法</a>
      <ul>
        <li><a href="#执行效率">执行效率</a></li>
        <li><a href="#内存消耗">内存消耗</a></li>
        <li><a href="#稳定性">稳定性</a></li>
      </ul>
    </li>
    <li><a href="#冒泡排序">冒泡排序</a>
      <ul>
        <li><a href="#分析冒泡排序">分析冒泡排序</a></li>
      </ul>
    </li>
    <li><a href="#插入排序">插入排序</a>
      <ul>
        <li><a href="#分析插入排序">分析插入排序</a></li>
      </ul>
    </li>
    <li><a href="#选择排序">选择排序</a>
      <ul>
        <li><a href="#分析选择排序">分析选择排序</a></li>
      </ul>
    </li>
    <li><a href="#为什么插入排序要比冒泡排序更受欢迎">为什么插入排序要比冒泡排序更受欢迎</a></li>
    <li><a href="#归并排序">归并排序</a>
      <ul>
        <li><a href="#分析归并排序">分析归并排序</a></li>
      </ul>
    </li>
    <li><a href="#快速排序">快速排序</a></li>
    <li><a href="#快排和归并的区别">快排和归并的区别</a></li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="排序">
  排序
  <a class="anchor" href="#%e6%8e%92%e5%ba%8f">#</a>
</h1>
<p>常用的三类排序算法：</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡、插入、选择</td>
<td><code>O(n^2)</code></td>
</tr>
<tr>
<td>快排、归并</td>
<td><code>O(nlogn)</code></td>
</tr>
<tr>
<td>桶、计数、基数</td>
<td><code>O(n)</code></td>
</tr>
</tbody>
</table>
<p>插入排序和冒泡排序的时间复杂度相同，为什么更倾向于使用插入排序算法而不是冒泡排序算法？</p>
<h2 id="分析排序算法">
  分析排序算法
  <a class="anchor" href="#%e5%88%86%e6%9e%90%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95">#</a>
</h2>
<h3 id="执行效率">
  执行效率
  <a class="anchor" href="#%e6%89%a7%e8%a1%8c%e6%95%88%e7%8e%87">#</a>
</h3>
<p>排序算法执行效率的分析，可以通过几个方面来衡量：</p>
<ol>
<li>最好情况、最坏情况、平均情况时间复杂度</li>
<li>时间复杂度的系数、常数、低阶我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但
是实际的软件开发中，排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，就要把
系数、常数、低阶也考虑进来。</li>
<li>基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果在分析排序算法的执行效率的时候，
应该把比较次数和交换（或移动）次数也考虑进去。</li>
</ol>
<h3 id="内存消耗">
  内存消耗
  <a class="anchor" href="#%e5%86%85%e5%ad%98%e6%b6%88%e8%80%97">#</a>
</h3>
<p>算法的内存消耗可以通过空间复杂度来衡量，针对排序算法的空间复杂度，有一个概念，<strong>原地排序</strong>（Sorted in place），就是<strong>特指“空间复杂度”
是 <code>O(1)</code> 的排序算法</strong>。冒泡排序，插入排序，选择排序都是原地排序算法。</p>
<h3 id="稳定性">
  稳定性
  <a class="anchor" href="#%e7%a8%b3%e5%ae%9a%e6%80%a7">#</a>
</h3>
<p>稳定性就是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
<p>比如一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。</p>
<p>这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作<strong>稳定的排序算法</strong>；
如果前后顺序发生变化，那对应的排序算法就叫作<strong>不稳定的排序算法</strong>。</p>
<h4 id="为什么要考察排序算法的稳定性">
  为什么要考察排序算法的稳定性
  <a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e8%80%83%e5%af%9f%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e7%9a%84%e7%a8%b3%e5%ae%9a%e6%80%a7">#</a>
</h4>
<p>真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个 key 来排序。
比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望
按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。</p>
<p>最先想到的方法是：我们先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思
路理解起来不难，但是实现起来会很复杂。</p>
<p>借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，
我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。</p>
<p>为什么呢？稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排
序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。</p>
<h2 id="冒泡排序">
  冒泡排序
  <a class="anchor" href="#%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f">#</a>
</h2>
<p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。<strong>一次冒泡
会让至少一个元素移动到它应该在的位置</strong>，重复 n 次，就完成了 n 个数据的排序工作。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BubbleSort</span>(<span style="color:#a6e22e">a</span> []<span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">length</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">a</span>)
	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">a</span>) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> {
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">flag</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">false</span>
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">j</span> <span style="color:#f92672">++</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span>] &gt; <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] {
				<span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span>], <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] = <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span>]
				<span style="color:#a6e22e">flag</span> = <span style="color:#66d9ef">true</span>
			}
		}
		<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">flag</span> {
			<span style="color:#66d9ef">break</span>
		}
	}
}
</code></pre></div><h3 id="分析冒泡排序">
  分析冒泡排序
  <a class="anchor" href="#%e5%88%86%e6%9e%90%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f">#</a>
</h3>
<ol>
<li>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 <code>O(1)</code>，是一个原地排序算法。</li>
<li>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。当有相邻的两个元素大小相等的时候，不做交换，相同大小的数据在排序
前后不会改变顺序，所以冒泡排序是稳定的排序算法。</li>
<li>最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 <code>O(n)</code>。而最
坏的情况是，要排序的数据刚好是倒序排列的，需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 <code>O(n^2)</code>。</li>
</ol>
<h2 id="插入排序">
  插入排序
  <a class="anchor" href="#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f">#</a>
</h2>
<p>插入排序，将数组中的数据分为两个区间，<strong>已排序区间</strong>和<strong>未排序区间</strong>。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序
区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p>
<p><img src="../../images/insert_sort.jpg" alt="insert_sort" /></p>
<p>插入排序也包含两种操作，一种是<strong>元素的比较</strong>，一种是<strong>元素的移动</strong>。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次
比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">InsertSort</span>(<span style="color:#a6e22e">a</span> []<span style="color:#66d9ef">int</span>)  {
	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">a</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> {
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span>]
		<span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
		<span style="color:#75715e">// 查找要插入的位置并移动数据
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">j</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">--</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span>] &gt; <span style="color:#a6e22e">value</span> {
				<span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] = <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span>]
			} <span style="color:#66d9ef">else</span> {
				<span style="color:#66d9ef">break</span>
			}
		}
		<span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] = <span style="color:#a6e22e">value</span>
	}
}
</code></pre></div><h3 id="分析插入排序">
  分析插入排序
  <a class="anchor" href="#%e5%88%86%e6%9e%90%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f">#</a>
</h3>
<ol>
<li>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 <code>O(1)</code>，也就是一个原地排序算法。</li>
<li>插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所
以插入排序是稳定的排序算法。</li>
<li>如果要排序的数据已经是有序的，并不需要搬移任何数据。如果从尾到头在有序数据组里面查找插入位置，每次只需要比较一个
数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 <code>O(n)</code>。注意，这里是从尾到头遍历已经有序的数据。如果数组
是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 <code>O(n^2)</code>。</li>
</ol>
<h2 id="选择排序">
  选择排序
  <a class="anchor" href="#%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f">#</a>
</h2>
<p>选择排序有点类似插入排序，也分<strong>已排序区间</strong>和<strong>未排序区间</strong>。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p>
<p><img src="../../images/selection_sort.jpg" alt="selection_sort" /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">SelectionSort</span>(<span style="color:#a6e22e">a</span> []<span style="color:#66d9ef">int</span>)  {
	<span style="color:#a6e22e">length</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">a</span>)
	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">a</span>) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> {
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">minIndex</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">j</span> <span style="color:#f92672">++</span> { <span style="color:#75715e">// 找到最小值
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span>] &lt; <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">minIndex</span>] {
                <span style="color:#a6e22e">minIndex</span> = <span style="color:#a6e22e">j</span>
            }
        }
        <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">minIndex</span>] = <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">minIndex</span>], <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span>] <span style="color:#75715e">// 交换
</span><span style="color:#75715e"></span>	}
}
</code></pre></div><h3 id="分析选择排序">
  分析选择排序
  <a class="anchor" href="#%e5%88%86%e6%9e%90%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f">#</a>
</h3>
<ol>
<li>选择排序算法的运行并不需要额外的存储空间，空间复杂度是 <code>O(1)</code>，是一个原地排序算法。</li>
<li>选择排序中，每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。</li>
<li>选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 <code>O(n^2)</code>。因为每一轮选择排序都要遍历未排序区间，找到最小值。</li>
</ol>
<h2 id="为什么插入排序要比冒泡排序更受欢迎">
  为什么插入排序要比冒泡排序更受欢迎
  <a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f%e8%a6%81%e6%af%94%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f%e6%9b%b4%e5%8f%97%e6%ac%a2%e8%bf%8e">#</a>
</h2>
<p>冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span>] &gt; <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] {
    <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span>], <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] = <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span>]
    <span style="color:#a6e22e">flag</span> = <span style="color:#66d9ef">true</span>
}


<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span>] &gt; <span style="color:#a6e22e">value</span> {
    <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] = <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">j</span>]
} <span style="color:#66d9ef">else</span> {
    <span style="color:#66d9ef">break</span>
}
</code></pre></div><h2 id="归并排序">
  归并排序
  <a class="anchor" href="#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f">#</a>
</h2>
<p>归并排序使用的就是<strong>分治思想</strong>。分治，就是将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p>
<p>分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。</p>
<p><img src="../../images/merge_sort.jpg" alt="merge_sort" /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">MergeSort</span>(<span style="color:#a6e22e">a</span> []<span style="color:#66d9ef">int</span>)  {
	<span style="color:#a6e22e">length</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">a</span>)
	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">a</span>) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> {
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#a6e22e">mergeSort</span>(<span style="color:#a6e22e">a</span>, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mergeSort</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">start</span>, <span style="color:#a6e22e">end</span> <span style="color:#66d9ef">int</span>)  {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">end</span> {
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#a6e22e">mid</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">start</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">end</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
	<span style="color:#a6e22e">mergeSort</span>(<span style="color:#a6e22e">arr</span>, <span style="color:#a6e22e">start</span>, <span style="color:#a6e22e">mid</span>)
	<span style="color:#a6e22e">mergeSort</span>(<span style="color:#a6e22e">arr</span>, <span style="color:#a6e22e">mid</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">end</span>)
	<span style="color:#a6e22e">merge</span>(<span style="color:#a6e22e">arr</span>, <span style="color:#a6e22e">start</span>, <span style="color:#a6e22e">mid</span>, <span style="color:#a6e22e">end</span>)
}

<span style="color:#75715e">// arr 是原切片，只传入分组后的下标
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">merge</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">start</span>, <span style="color:#a6e22e">mid</span>, <span style="color:#a6e22e">end</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#75715e">// 申请一个可以存放两个分组所有元素的临时切片
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">tmpArr</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">end</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">start</span> <span style="color:#75715e">// 第一个分组的开始位置
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mid</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#75715e">// 第二个分组的开始位置
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">mid</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">end</span>; <span style="color:#a6e22e">k</span><span style="color:#f92672">++</span> { <span style="color:#75715e">// 每个分组都已经排好顺序
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>] &lt; <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>] {  <span style="color:#75715e">// 直接比较每个分组相同位置的元素大小
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">tmpArr</span>[<span style="color:#a6e22e">k</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>] <span style="color:#75715e">// 小的元素放到临时切片中
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#a6e22e">tmpArr</span>[<span style="color:#a6e22e">k</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>]
			<span style="color:#a6e22e">j</span><span style="color:#f92672">++</span>
		}
	}
	copy(<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">start</span> : <span style="color:#a6e22e">end</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">tmpArr</span>) <span style="color:#75715e">// 将临时切片的元素拷贝到原切片的对应位置
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="分析归并排序">
  分析归并排序
  <a class="anchor" href="#%e5%88%86%e6%9e%90%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f">#</a>
</h3>
<ol>
<li>因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。归并排序不是原地排序算法。每次合并操作都需要申
请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空
间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 <code>O(n)</code>。</li>
<li>合并的过程中，如果 <code>A[p…q]</code> 和 <code>A[q+1…r]</code> 之间有值相同的元素，我们可以先把 <code>A[p…q]</code> 中的元素放入 <code>tmp</code> 数组。这样就保证了
值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法</li>
<li>归并排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 <code>O(nlogn)</code>。</li>
</ol>
<h2 id="快速排序">
  快速排序
  <a class="anchor" href="#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f">#</a>
</h2>
<p>快速排序简称“快排”，使用的也是<strong>分治思想</strong>。</p>
<p>快排的思想：如果要排序数组中下标从 p 到 r 之间的一组数据，选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。我们遍历 p 到 r 之间的
数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，
前面 p 到 <code>q-1</code> 之间都是小于 pivot 的，中间是 pivot，后面的 <code>q+1</code> 到 r 之间是大于 pivot 的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">QuickSort</span>(<span style="color:#a6e22e">a</span> []<span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">length</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">a</span>)
	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">a</span>) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> {
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#a6e22e">separateSort</span>(<span style="color:#a6e22e">a</span>, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">separateSort</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">start</span>, <span style="color:#a6e22e">end</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">end</span> {
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">partition</span>(<span style="color:#a6e22e">arr</span>, <span style="color:#a6e22e">start</span>, <span style="color:#a6e22e">end</span>)
	<span style="color:#a6e22e">separateSort</span>(<span style="color:#a6e22e">arr</span>, <span style="color:#a6e22e">start</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
	<span style="color:#a6e22e">separateSort</span>(<span style="color:#a6e22e">arr</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">end</span>)
}
</code></pre></div><p>如果我们不考虑空间消耗的话，<code>partition()</code> 分区函数可以写得非常简单。我们申请两个临时数组 X 和 Y，遍历 <code>A[p…r]</code>，将小于 pivot 的元素
都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 <code>A[p…r]</code>。但是，这样就不是原地排
序算法了。</p>
<p><img src="../../images/qucik_sort.jpg" alt="qucik_sort" /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">partition</span>(<span style="color:#a6e22e">arr</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">start</span>, <span style="color:#a6e22e">end</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#75715e">// 选取最后一位当对比数字
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pivot</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">end</span>]

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> = <span style="color:#a6e22e">start</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">start</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#a6e22e">end</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>] &lt; <span style="color:#a6e22e">pivot</span> {
			<span style="color:#66d9ef">if</span> !(<span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">j</span>) {
				<span style="color:#75715e">// 交换位置
</span><span style="color:#75715e"></span>				<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">j</span>], <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>]
			}
			<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
		}
	}

	<span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">end</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">end</span>], <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>]

	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span>
}
</code></pre></div><p>处理有点类似选择排序。通过游标 i 把 <code>A[p…r-1]</code> 分成两部分。<code>A[p…i-1]</code> 的元素都是小于 pivot 的，暂且叫它“已处理区间”，<code>A[i…r-1]</code> 
是“未处理区间”。每次都从未处理的区间 <code>A[i…r-1]</code> 中取一个元素 <code>A[j]</code>，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾
部，也就是 <code>A[i]</code> 的位置。</p>
<h2 id="快排和归并的区别">
  快排和归并的区别
  <a class="anchor" href="#%e5%bf%ab%e6%8e%92%e5%92%8c%e5%bd%92%e5%b9%b6%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
</h2>
<p><img src="../../images/quick_and_merge.jpg" alt="quick_and_merge" /></p>
<ul>
<li>归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。</li>
<li>归并排序非原地排序算法，快速排序可以实现原地排序。</li>
<li>归并排序是稳定的排序，快速排序不是。</li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/shipengqi/algorithm-learn/commit/f0affa43a408758a4a1a44d5288e6e0087d8415f" title='Last modified by shipengqi | June 18, 2020' target="_blank" rel="noopener">
      <img src="/algorithm-learn/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>June 18, 2020</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/shipengqi/algorithm-learn/edit/master/content//docs/07_sort.md" target="_blank" rel="noopener">
      <img src="/algorithm-learn/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>

</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#分析排序算法">分析排序算法</a>
      <ul>
        <li><a href="#执行效率">执行效率</a></li>
        <li><a href="#内存消耗">内存消耗</a></li>
        <li><a href="#稳定性">稳定性</a></li>
      </ul>
    </li>
    <li><a href="#冒泡排序">冒泡排序</a>
      <ul>
        <li><a href="#分析冒泡排序">分析冒泡排序</a></li>
      </ul>
    </li>
    <li><a href="#插入排序">插入排序</a>
      <ul>
        <li><a href="#分析插入排序">分析插入排序</a></li>
      </ul>
    </li>
    <li><a href="#选择排序">选择排序</a>
      <ul>
        <li><a href="#分析选择排序">分析选择排序</a></li>
      </ul>
    </li>
    <li><a href="#为什么插入排序要比冒泡排序更受欢迎">为什么插入排序要比冒泡排序更受欢迎</a></li>
    <li><a href="#归并排序">归并排序</a>
      <ul>
        <li><a href="#分析归并排序">分析归并排序</a></li>
      </ul>
    </li>
    <li><a href="#快速排序">快速排序</a></li>
    <li><a href="#快排和归并的区别">快排和归并的区别</a></li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












