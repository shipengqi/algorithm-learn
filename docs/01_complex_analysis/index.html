<!DOCTYPE html>
<html lang="en" dir=>

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="为什么需要复杂度分析#在实际工作中，我们把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析？
首先这种方法叫事后统计法，这种方法的局限性：
 依赖测试环境。代码在不同的环境运行，结果是不同的，比如一个酷睿 i9，和酷睿 i3，很明显 i9 处理速度要快的多。 测试结构受数据规模的影响。测试数据规模太小，测试结果可能无法真实地反应算法的性能。  大 O 时间复杂度表示法#func cal(n int) int { sum := 0 for i := 1; i &lt;= n; &#43;&#43;i { sum = sum &#43; i } return sum } 上面的代码，假设每行代码执行的时间都一样，为 unit_time。那么，第 2、3 行代码分别需要 1 个 unit_time 的执行时间， 第 4、5 行都运行了 n 遍，所以需要 2n * unit_time 的执行时间，所以这段代码总的执行时间就是 (2n&#43;2)* unit_time。 可以看出来，所有代码的执行时间 T(n) 与每行代码的执行次数成正比。
func cal2(n int) int { sum := 0 for i := 1; i &lt;= n; i&#43;&#43; { for j := 1; j &lt;= n; j &#43;&#43; { sum = sum &#43; i } } return sum } 上面的代码，第 2、3 行代码，每行都需要 1 个 unit_time 的执行时间，第 4 行代码循环执行了 n 遍，需要 n * unit_time的执 行时间，第 5,6 行代码循环执行了 n^2 遍，所以需要 2n^2 * unit_time 的执行时间。所以，整段代码总的执行 时间T(n) = (2n^2&#43;n&#43;3)*unit_time。">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="复杂度分析" />
<meta property="og:description" content="为什么需要复杂度分析#在实际工作中，我们把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析？
首先这种方法叫事后统计法，这种方法的局限性：
 依赖测试环境。代码在不同的环境运行，结果是不同的，比如一个酷睿 i9，和酷睿 i3，很明显 i9 处理速度要快的多。 测试结构受数据规模的影响。测试数据规模太小，测试结果可能无法真实地反应算法的性能。  大 O 时间复杂度表示法#func cal(n int) int { sum := 0 for i := 1; i &lt;= n; &#43;&#43;i { sum = sum &#43; i } return sum } 上面的代码，假设每行代码执行的时间都一样，为 unit_time。那么，第 2、3 行代码分别需要 1 个 unit_time 的执行时间， 第 4、5 行都运行了 n 遍，所以需要 2n * unit_time 的执行时间，所以这段代码总的执行时间就是 (2n&#43;2)* unit_time。 可以看出来，所有代码的执行时间 T(n) 与每行代码的执行次数成正比。
func cal2(n int) int { sum := 0 for i := 1; i &lt;= n; i&#43;&#43; { for j := 1; j &lt;= n; j &#43;&#43; { sum = sum &#43; i } } return sum } 上面的代码，第 2、3 行代码，每行都需要 1 个 unit_time 的执行时间，第 4 行代码循环执行了 n 遍，需要 n * unit_time的执 行时间，第 5,6 行代码循环执行了 n^2 遍，所以需要 2n^2 * unit_time 的执行时间。所以，整段代码总的执行 时间T(n) = (2n^2&#43;n&#43;3)*unit_time。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://shipengqi.github.io/algorithm-learn/docs/01_complex_analysis/" />
<meta property="article:modified_time" content="2020-06-18T17:06:12+08:00" />
<title>复杂度分析 | Algorithm Learning</title>
<link rel="manifest" href="/algorithm-learn/manifest.json">
<link rel="icon" href="/algorithm-learn/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/algorithm-learn/book.min.b3215d9d1d18d9051e7fbe8f256ff80e30f41d29073b86348e230d297b771002.css" integrity="sha256-syFdnR0Y2QUef76PJW/4DjD0HSkHO4Y0jiMNKXt3EAI=">
<script defer src="/algorithm-learn/en.search.min.511cae842a1aa3c6a84d63e20bade0ff9213702b34b6fe826804dc6e1b02a9e3.js" integrity="sha256-URyuhCoao8aoTWPiC63g/5ITcCs0tv6CaATcbhsCqeM="></script>

<script defer src="/algorithm-learn/sw.min.eaff391435f87073ec5af42687d96b565bbf32cc51b0c17648cd12c7d96f6307.js" integrity="sha256-6v85FDX4cHPsWvQmh9lrVlu/MsxRsMF2SM0Sx9lvYwc="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir=>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/algorithm-learn"><span>Algorithm Learning</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>






  
<ul>
  
  <li>
    <a href="https://github.com/shipengqi/algorithm-learn" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://shipengqi.github.io/" target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
</ul>







  <p>━━━━━━━━━━━━━━━━━━━━</p>
<ul>
<li><a href="/algorithm-learn/docs/01_complex_analysis/"class=active>复杂度分析</a></li>
<li><a href="/algorithm-learn/docs/02_array/">数组</a></li>
<li><a href="/algorithm-learn/docs/03_link_list/">链表</a></li>
<li><a href="/algorithm-learn/docs/04_stack/">栈</a></li>
<li><a href="/algorithm-learn/docs/05_queue/">队列</a></li>
<li><a href="/algorithm-learn/docs/06_recursion/">递归</a></li>
<li><a href="/algorithm-learn/docs/07_sort/">排序</a></li>
<li><a href="/algorithm-learn/docs/08_linear_sort/">线性排序</a></li>
<li><a href="/algorithm-learn/docs/09_binary_search/">二分查找</a></li>
<li><a href="/algorithm-learn/docs/10_skip_list/">跳表</a></li>
<li><a href="/algorithm-learn/docs/11_hash_table/">散列表</a></li>
<li><a href="/algorithm-learn/docs/12_hash_algo/">哈希算法</a></li>
<li><a href="/algorithm-learn/docs/13_binary_tree/">二叉树</a></li>
<li><a href="/algorithm-learn/docs/14_heap/">堆</a></li>
<li><a href="/algorithm-learn/docs/15_graph/">图</a></li>
<li><a href="/algorithm-learn/docs/16_string_match_algo/">字符串匹配算法</a></li>
<li><a href="/algorithm-learn/docs/17_trie/">Trie 树</a></li>
<li><a href="/algorithm-learn/docs/18_ac/">AC 自动机</a></li>
<li><a href="/algorithm-learn/docs/19_greedy/">贪心算法</a></li>
<li><a href="/algorithm-learn/docs/20_deivide_conquer/">分治算法</a></li>
<li><a href="/algorithm-learn/docs/21_backtracking/">回溯算法</a></li>
<li><a href="/algorithm-learn/docs/22_dynamic_programming/">动态规划</a></li>
<li><a href="/algorithm-learn/docs/23_bit_map/">位图</a></li>
<li><a href="/algorithm-learn/docs/24_bmore_tree/">索引</a></li>
<li><a href="/algorithm-learn/docs/25_vector/">向量空间</a>
<!-- raw HTML omitted --></li>
</ul>










</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/algorithm-learn/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>复杂度分析</strong>

  <label for="toc-control">
    
    <img src="/algorithm-learn/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#为什么需要复杂度分析">为什么需要复杂度分析</a></li>
    <li><a href="#大-o-时间复杂度表示法">大 O 时间复杂度表示法</a>
      <ul>
        <li><a href="#如何分析一段代码的时间复杂度">如何分析一段代码的时间复杂度</a></li>
        <li><a href="#复杂度量级">复杂度量级</a></li>
        <li><a href="#空间复杂度分析">空间复杂度分析</a></li>
        <li><a href="#最好最坏情况时间复杂度">最好、最坏情况时间复杂度</a></li>
        <li><a href="#平均情况时间复杂度">平均情况时间复杂度</a></li>
        <li><a href="#均摊时间复杂度">均摊时间复杂度</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h2 id="为什么需要复杂度分析">
  为什么需要复杂度分析
  <a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90">#</a>
</h2>
<p>在实际工作中，我们把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析？</p>
<p>首先这种方法叫<strong>事后统计法</strong>，这种方法的局限性：</p>
<ol>
<li>依赖测试环境。代码在不同的环境运行，结果是不同的，比如一个酷睿 i9，和酷睿 i3，很明显 i9 处理速度要快的多。</li>
<li>测试结构受数据规模的影响。测试数据规模太小，测试结果可能无法真实地反应算法的性能。</li>
</ol>
<h2 id="大-o-时间复杂度表示法">
  大 O 时间复杂度表示法
  <a class="anchor" href="#%e5%a4%a7-o-%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6%e8%a1%a8%e7%a4%ba%e6%b3%95">#</a>
</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">cal</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">n</span>; <span style="color:#f92672">++</span><span style="color:#a6e22e">i</span> {
        <span style="color:#a6e22e">sum</span> = <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">i</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>
}
</code></pre></div><p>上面的代码，假设每行代码执行的时间都一样，为 <code>unit_time</code>。那么，第 2、3 行代码分别需要 1 个 <code>unit_time</code> 的执行时间，
第 4、5 行都运行了 n 遍，所以需要 <code>2n * unit_time</code> 的执行时间，所以这段代码总的执行时间就是 <code>(2n+2)* unit_time</code>。
可以看出来，所有代码的执行时间 <code>T(n)</code> 与每行代码的执行次数成正比。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">cal2</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
 <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
 <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">j</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">j</span> <span style="color:#f92672">++</span> {
   <span style="color:#a6e22e">sum</span> = <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">i</span>
  }
 }
 <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>
}
</code></pre></div><p>上面的代码，第 2、3 行代码，每行都需要 1 个 <code>unit_time</code> 的执行时间，第 4 行代码循环执行了 n 遍，需要 <code>n * unit_time</code>的执
行时间，第 5,6 行代码循环执行了 <code>n^2</code> 遍，所以需要 <code>2n^2 * unit_time</code> 的执行时间。所以，整段代码总的执行
时间<code>T(n) = (2n^2+n+3)*unit_time</code>。</p>
<p>我们不知道 <code>unit_time</code> 的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，
<strong>所有代码的执行时间 <code>T(n)</code> 与每行代码的执行次数 <code>n</code> 成正比</strong>。
把这个规律总结成一个公式:</p>
<pre><code>T(n) = O(f(n))
</code></pre><p><strong><code>T(n)</code> 表示代码执行的时间；<code>n</code> 表示数据规模的大小；<code>f(n)</code> 表示每行代码执行的次数总和。公式中的 <code>O</code>，表示代码的执行
时间 <code>T(n)</code> 与 <code>f(n)</code> 表达式成正比</strong>。</p>
<p>所以，第一个例子中的 <code>T(n) = O(2n+2)</code>，第二个例子中的 <code>T(n) = O(2n^2+n+3)</code>。这就是<strong>大 O 时间复杂度表示法</strong>。</p>
<p>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是<strong>表示代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时
间复杂度（asymptotic time complexity），简称时间复杂度</strong>。</p>
<h3 id="如何分析一段代码的时间复杂度">
  如何分析一段代码的时间复杂度
  <a class="anchor" href="#%e5%a6%82%e4%bd%95%e5%88%86%e6%9e%90%e4%b8%80%e6%ae%b5%e4%bb%a3%e7%a0%81%e7%9a%84%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6">#</a>
</h3>
<ol>
<li>只关注循环执行次数最多的一段代码，例如，第一个例子中的 <code>T(n) = O(2n+2)</code>，总的时间复杂度就是 <code>O(n)</code>。第二个例子中
的 <code>T(n) = O(2n^2+n+3)</code>。总的时间复杂度就是 <code>O(n^2)</code>。</li>
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>
<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">cal3</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
 <span style="color:#a6e22e">ret</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
 <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
  <span style="color:#a6e22e">ret</span> = <span style="color:#a6e22e">ret</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">i</span>)
 }
 <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ret</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
 <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
 <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
  <span style="color:#a6e22e">sum</span> = <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">i</span>
 }
 <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>
}
</code></pre></div><p>单独看 <code>cal3()</code> 函数。假设 <code>f()</code> 只是一个普通的操作，那第 4～6 行的时间复杂度就是，<code>T1(n) = O(n)</code>。
但 <code>f()</code> 函数本身不是一个简单的操作，它的时间复杂度是 <code>T2(n) = O(n)</code>，所以，整个 <code>cal()</code> 函数的时间复杂度就是，
<code>T(n) = T1(n) * T2(n) = O(n*n) = O(n^2)</code>。</p>
<h3 id="复杂度量级">
  复杂度量级
  <a class="anchor" href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e9%87%8f%e7%ba%a7">#</a>
</h3>
<p>按数量级递增：</p>
<pre><code>常量阶 O(1)            指数阶 O(2^n)
对数阶 O(logn)         阶乘阶 O(n!)
线性阶 O(n)
线性对数阶 O(nlogn)
平方阶 O(n^2)，立方阶 O(n^3)，k 次方阶 O(n^k)
</code></pre><p>上面的复杂度量级，可以分为两类，<strong>多项式量级</strong>和<strong>非多项式量级</strong>。</p>
<h4 id="非多项式量级">
  非多项式量级
  <a class="anchor" href="#%e9%9d%9e%e5%a4%9a%e9%a1%b9%e5%bc%8f%e9%87%8f%e7%ba%a7">#</a>
</h4>
<p>时间复杂度为<strong>非多项式量级</strong>的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。</p>
<p>非多项式量级只有两个：<code>O(2^n)</code> 和 <code>O(n!)</code>。</p>
<p><strong>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复
杂度的算法其实是非常低效的算法</strong>。</p>
<h4 id="常量阶-o1">
  常量阶 O(1)
  <a class="anchor" href="#%e5%b8%b8%e9%87%8f%e9%98%b6-o1">#</a>
</h4>
<p><code>O(1)</code> 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度
也是 <code>O(1)</code>，而不是 <code>O(3)</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">8</span>;
<span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">6</span>;
<span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">j</span>;
</code></pre></div><p>只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 <code>O(1)</code>。或者说，一般情况下，只要算法中不存在循
环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是 <code>Ο(1)</code>。</p>
<h4 id="对数阶-ologn--线性对数阶-onlogn">
  对数阶 O(logn)  线性对数阶 O(nlogn)
  <a class="anchor" href="#%e5%af%b9%e6%95%b0%e9%98%b6-ologn--%e7%ba%bf%e6%80%a7%e5%af%b9%e6%95%b0%e9%98%b6-onlogn">#</a>
</h4>
<p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">n</span> {
  <span style="color:#a6e22e">i</span> = <span style="color:#a6e22e">i</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
}
</code></pre></div><p>上面的代码中，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。变量 i 的取值就是一个等比数列。
我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 <code>2^x=n</code> 求解 x。<code>x=log2(n)</code>，所以，这段代码的时间复杂度
就是 <code>O(log2(n))</code>。</p>
<p>不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 <code>O(logn)</code>。</p>
<p>如果理解了 <code>O(logn)</code>，那 <code>O(nlogn)</code> 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 <code>O(logn)</code>，
我们循环执行 n 遍，时间复杂度就是 <code>O(nlogn)</code> 了。而且，<code>O(nlogn)</code> 也是一种非常常见的算法时间复杂度。比如，归并排序、快速
排序的时间复杂度都是 <code>O(nlogn)</code>。</p>
<h3 id="空间复杂度分析">
  空间复杂度分析
  <a class="anchor" href="#%e7%a9%ba%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90">#</a>
</h3>
<p><strong>空间复杂度全称是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系</strong>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">DemopPint</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) {
 <span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">n</span>)
 <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">++</span> {
  <span style="color:#a6e22e">a</span> = append(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">i</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">i</span>)
 }
 <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">--</span> {
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span>])
 }
}
</code></pre></div><p>第 2 行代码中，申请了一个大小为 n  的 <code>int</code> 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复
杂度就是 <code>O(n)</code>。</p>
<p>常见的空间复杂度就是 <code>O(1)</code>、<code>O(n)</code>、<code>O(n^2)</code>，像 <code>O(logn)</code>、<code>O(nlogn)</code> 这样的对数阶复杂度平时都用不到。</p>
<h3 id="最好最坏情况时间复杂度">
  最好、最坏情况时间复杂度
  <a class="anchor" href="#%e6%9c%80%e5%a5%bd%e6%9c%80%e5%9d%8f%e6%83%85%e5%86%b5%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6">#</a>
</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// n 表示数组 array 的长度 int
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">find</span>(<span style="color:#a6e22e">array</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
 <span style="color:#a6e22e">pos</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
 <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">++</span> {
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">array</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">x</span> {
   <span style="color:#a6e22e">pos</span> = <span style="color:#a6e22e">i</span>
  }
 }
 <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pos</span>
}
</code></pre></div><p>按照前面的方法分析，很明显复杂度是 <code>O(n)</code>。</p>
<p>但是在数组中查找一个数据，并不需要每次都把整个数组都遍历一遍，因为有可能中途找到就可以提前结束循环了。我们优化一下代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">find</span>(<span style="color:#a6e22e">array</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
 <span style="color:#a6e22e">pos</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
 <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">++</span> {
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">array</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">x</span> {
   <span style="color:#a6e22e">pos</span> = <span style="color:#a6e22e">i</span>
   <span style="color:#66d9ef">break</span>
  }
 }
 <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pos</span>
}
</code></pre></div><p>优化以后复杂度明显不再是 <code>O(n)</code>。</p>
<p>为了表示代码在不同情况下的不同时间复杂度，需要引入三个概念：<strong>最好情况时间复杂度、最坏情况时间复杂度</strong>。</p>
<p>最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。比如上面的例子，在最理想的情况下，要查找的变量 <code>x</code>
正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。复杂度就是 <code>O(1)</code>。</p>
<p>同理，最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。上面的例子，如果数组中没有要查找的变量 <code>x</code>，我们需
要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。复杂度就是<code>O(n)</code>。</p>
<h3 id="平均情况时间复杂度">
  平均情况时间复杂度
  <a class="anchor" href="#%e5%b9%b3%e5%9d%87%e6%83%85%e5%86%b5%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6">#</a>
</h3>
<p>最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，
需要引入另一个概念：<strong>平均情况时间复杂度</strong>，后面我简称为<strong>平均时间复杂度</strong>。</p>
<p>还是前面的例子，要查找的变量 x 在数组中的位置，有 <code>n+1</code> 种情况：在数组的 <code>0~n-1</code> 位置中和不在数组中。我们把每种情况下，查找
需要遍历的元素个数累加起来，然后再除以 <code>n+1</code>，就可以得到需要遍历的元素个数的平均值。时间复杂度的大 O 标记法中，可以省略掉系数、
低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是 <code>O(n)</code>。</p>
<pre><code>(1 + 2 + 3 + n + n)/(n + 1) = n(n + 3)/2(n + 1)
</code></pre><p>这个结论虽然是正确的，但是计算过程稍微有点儿问题。是什么问题？ <code>n+1</code> 种情况，出现的概率并不是一样的。</p>
<p>要查找的变量 <code>x</code>，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，假设在数组中与不在数组中的概率
都为 <code>1/2</code>。另外，要查找的数据出现在 <code>0~n-1</code> 这 <code>n</code> 个位置的概率也是一样的，为 <code>1/n</code>。所以，根据概率乘法法则，要查找的
数据出现在 <code>0~n-1</code> 中任意位置的概率就是 <code>1/(2n)</code>。</p>
<p>引入概率之后，前面那段代码的加权平均值为 <code>(3n+1)/4</code>。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍
然是 <code>O(n)</code>。</p>
<p>很多时候，我们使用一个复杂度就可以满足需求了。</p>
<h3 id="均摊时间复杂度">
  均摊时间复杂度
  <a class="anchor" href="#%e5%9d%87%e6%91%8a%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6">#</a>
</h3>
<p>均摊时间复杂度就是一种特殊的平均时间复杂度，<strong>一般均摊时间复杂度就等于最好情况时间复杂度</strong>。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/shipengqi/algorithm-learn/commit/f0affa43a408758a4a1a44d5288e6e0087d8415f" title='Last modified by shipengqi | June 18, 2020' target="_blank" rel="noopener">
      <img src="/algorithm-learn/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>June 18, 2020</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/shipengqi/algorithm-learn/edit/master/content//docs/01_complex_analysis.md" target="_blank" rel="noopener">
      <img src="/algorithm-learn/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>

</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#为什么需要复杂度分析">为什么需要复杂度分析</a></li>
    <li><a href="#大-o-时间复杂度表示法">大 O 时间复杂度表示法</a>
      <ul>
        <li><a href="#如何分析一段代码的时间复杂度">如何分析一段代码的时间复杂度</a></li>
        <li><a href="#复杂度量级">复杂度量级</a></li>
        <li><a href="#空间复杂度分析">空间复杂度分析</a></li>
        <li><a href="#最好最坏情况时间复杂度">最好、最坏情况时间复杂度</a></li>
        <li><a href="#平均情况时间复杂度">平均情况时间复杂度</a></li>
        <li><a href="#均摊时间复杂度">均摊时间复杂度</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












