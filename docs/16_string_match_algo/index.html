<!DOCTYPE html>
<html lang="en" dir=>

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="字符串匹配算法#字符串匹配算法很常用，比如 js 中的 indexOf 函数，就依赖字符串匹配算法。
BF 算法#BF （Brute Force）算法叫作暴力匹配算法，也叫朴素匹配算法。简单，但是性能差。
字符串匹配算法有两个概念：主串和模式串。比如两个字符串 A 和 B，要在 A 中查找 B，A 就是主串，B 就是模式串。 主串的长度记作 n，模式串的长度记作 m。
BF 算法的思想就是在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m&#43;1 个子串，看有没有跟模式串匹配的。
比如主串是 &ldquo;aaaaa…aaaaaa&rdquo;（省略号表示有很多重复的字符 a），模式串是 &ldquo;aaaaab&rdquo;。每次都比对 m 个字符，要比对 n-m&#43;1 次，所以，这种算法的 最坏情况时间复杂度是 O(n*m)。
实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。朴素的字符串匹配算法就够用了。
RK 算法#RK 算法（Rabin-Karp）其实就是 BF 算法的升级版。BF 算法需要暴力地对比这 n-m&#43;1 个子串与模式串，但是，每次检查主串与子串是否匹配，需要依 次比对每个字符，所以 BF 算法的时间复杂度就比较高，是 O(n*m)。
RK 算法的思想是通过哈希算法对主串中的 n-m&#43;1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等（如果不 考虑哈希冲突的问题），那就说明对应的子串和模式串匹配了。但这只是提高了模式串与子串比较的效率。
提高哈希算法计算子串哈希值的效率#怎样设计哈希算法，假设要匹配的字符串的字符集中只包含 K 个字符，可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子 串的哈希值。">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="字符串匹配算法" />
<meta property="og:description" content="字符串匹配算法#字符串匹配算法很常用，比如 js 中的 indexOf 函数，就依赖字符串匹配算法。
BF 算法#BF （Brute Force）算法叫作暴力匹配算法，也叫朴素匹配算法。简单，但是性能差。
字符串匹配算法有两个概念：主串和模式串。比如两个字符串 A 和 B，要在 A 中查找 B，A 就是主串，B 就是模式串。 主串的长度记作 n，模式串的长度记作 m。
BF 算法的思想就是在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m&#43;1 个子串，看有没有跟模式串匹配的。
比如主串是 &ldquo;aaaaa…aaaaaa&rdquo;（省略号表示有很多重复的字符 a），模式串是 &ldquo;aaaaab&rdquo;。每次都比对 m 个字符，要比对 n-m&#43;1 次，所以，这种算法的 最坏情况时间复杂度是 O(n*m)。
实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。朴素的字符串匹配算法就够用了。
RK 算法#RK 算法（Rabin-Karp）其实就是 BF 算法的升级版。BF 算法需要暴力地对比这 n-m&#43;1 个子串与模式串，但是，每次检查主串与子串是否匹配，需要依 次比对每个字符，所以 BF 算法的时间复杂度就比较高，是 O(n*m)。
RK 算法的思想是通过哈希算法对主串中的 n-m&#43;1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等（如果不 考虑哈希冲突的问题），那就说明对应的子串和模式串匹配了。但这只是提高了模式串与子串比较的效率。
提高哈希算法计算子串哈希值的效率#怎样设计哈希算法，假设要匹配的字符串的字符集中只包含 K 个字符，可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子 串的哈希值。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://shipengqi.github.io/algorithm-learn/docs/16_string_match_algo/" />
<meta property="article:modified_time" content="2020-06-18T17:06:12+08:00" />
<title>字符串匹配算法 | Algorithm Learning</title>
<link rel="manifest" href="/algorithm-learn/manifest.json">
<link rel="icon" href="/algorithm-learn/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/algorithm-learn/book.min.b3215d9d1d18d9051e7fbe8f256ff80e30f41d29073b86348e230d297b771002.css" integrity="sha256-syFdnR0Y2QUef76PJW/4DjD0HSkHO4Y0jiMNKXt3EAI=">
<script defer src="/algorithm-learn/en.search.min.511cae842a1aa3c6a84d63e20bade0ff9213702b34b6fe826804dc6e1b02a9e3.js" integrity="sha256-URyuhCoao8aoTWPiC63g/5ITcCs0tv6CaATcbhsCqeM="></script>

<script defer src="/algorithm-learn/sw.min.eaff391435f87073ec5af42687d96b565bbf32cc51b0c17648cd12c7d96f6307.js" integrity="sha256-6v85FDX4cHPsWvQmh9lrVlu/MsxRsMF2SM0Sx9lvYwc="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir=>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/algorithm-learn"><span>Algorithm Learning</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>






  
<ul>
  
  <li>
    <a href="https://github.com/shipengqi/algorithm-learn" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://shipengqi.github.io/" target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
</ul>







  <p>━━━━━━━━━━━━━━━━━━━━</p>
<ul>
<li><a href="/algorithm-learn/docs/01_complex_analysis/">复杂度分析</a></li>
<li><a href="/algorithm-learn/docs/02_array/">数组</a></li>
<li><a href="/algorithm-learn/docs/03_link_list/">链表</a></li>
<li><a href="/algorithm-learn/docs/04_stack/">栈</a></li>
<li><a href="/algorithm-learn/docs/05_queue/">队列</a></li>
<li><a href="/algorithm-learn/docs/06_recursion/">递归</a></li>
<li><a href="/algorithm-learn/docs/07_sort/">排序</a></li>
<li><a href="/algorithm-learn/docs/08_linear_sort/">线性排序</a></li>
<li><a href="/algorithm-learn/docs/09_binary_search/">二分查找</a></li>
<li><a href="/algorithm-learn/docs/10_skip_list/">跳表</a></li>
<li><a href="/algorithm-learn/docs/11_hash_table/">散列表</a></li>
<li><a href="/algorithm-learn/docs/12_hash_algo/">哈希算法</a></li>
<li><a href="/algorithm-learn/docs/13_binary_tree/">二叉树</a></li>
<li><a href="/algorithm-learn/docs/14_heap/">堆</a></li>
<li><a href="/algorithm-learn/docs/15_graph/">图</a></li>
<li><a href="/algorithm-learn/docs/16_string_match_algo/"class=active>字符串匹配算法</a></li>
<li><a href="/algorithm-learn/docs/17_trie/">Trie 树</a></li>
<li><a href="/algorithm-learn/docs/18_ac/">AC 自动机</a></li>
<li><a href="/algorithm-learn/docs/19_greedy/">贪心算法</a></li>
<li><a href="/algorithm-learn/docs/20_deivide_conquer/">分治算法</a></li>
<li><a href="/algorithm-learn/docs/21_backtracking/">回溯算法</a></li>
<li><a href="/algorithm-learn/docs/22_dynamic_programming/">动态规划</a></li>
<li><a href="/algorithm-learn/docs/23_bit_map/">位图</a></li>
<li><a href="/algorithm-learn/docs/24_bmore_tree/">索引</a></li>
<li><a href="/algorithm-learn/docs/25_vector/">向量空间</a>
<!-- raw HTML omitted --></li>
</ul>










</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/algorithm-learn/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>字符串匹配算法</strong>

  <label for="toc-control">
    
    <img src="/algorithm-learn/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#bf-算法">BF 算法</a></li>
    <li><a href="#rk-算法">RK 算法</a>
      <ul>
        <li><a href="#提高哈希算法计算子串哈希值的效率">提高哈希算法计算子串哈希值的效率</a></li>
      </ul>
    </li>
    <li><a href="#bm-算法">BM 算法</a>
      <ul>
        <li><a href="#坏字符规则">坏字符规则</a></li>
        <li><a href="#好后缀规则">好后缀规则</a></li>
        <li><a href="#bm-算法实现">BM 算法实现</a></li>
      </ul>
    </li>
    <li><a href="#kmp-算法">KMP 算法</a></li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="字符串匹配算法">
  字符串匹配算法
  <a class="anchor" href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8c%b9%e9%85%8d%e7%ae%97%e6%b3%95">#</a>
</h1>
<p>字符串匹配算法很常用，比如 js 中的 <code>indexOf</code> 函数，就依赖字符串匹配算法。</p>
<h2 id="bf-算法">
  BF 算法
  <a class="anchor" href="#bf-%e7%ae%97%e6%b3%95">#</a>
</h2>
<p>BF （Brute Force）算法叫作暴力匹配算法，也叫朴素匹配算法。简单，但是性能差。</p>
<p>字符串匹配算法有两个概念：<strong>主串</strong>和<strong>模式串</strong>。比如两个字符串 A 和 B，要在 A 中查找 B，A 就是主串，B 就是模式串。
主串的长度记作 n，模式串的长度记作 m。</p>
<p>BF 算法的思想就是在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的。</p>
<p>比如主串是 &ldquo;aaaaa…aaaaaa&rdquo;（省略号表示有很多重复的字符 a），模式串是 &ldquo;aaaaab&rdquo;。每次都比对 m 个字符，要比对 n-m+1 次，所以，这种算法的
最坏情况时间复杂度是 <code>O(n*m)</code>。</p>
<p>实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。朴素的字符串匹配算法就够用了。</p>
<h2 id="rk-算法">
  RK 算法
  <a class="anchor" href="#rk-%e7%ae%97%e6%b3%95">#</a>
</h2>
<p>RK 算法（Rabin-Karp）其实就是 BF 算法的升级版。BF 算法需要暴力地对比这 n-m+1 个子串与模式串，但是，每次检查主串与子串是否匹配，需要依
次比对每个字符，所以 BF 算法的时间复杂度就比较高，是 <code>O(n*m)</code>。</p>
<p>RK 算法的思想是通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等（如果不
考虑哈希冲突的问题），那就说明对应的子串和模式串匹配了。但这只是<strong>提高了模式串与子串比较的效率</strong>。</p>
<h3 id="提高哈希算法计算子串哈希值的效率">
  提高哈希算法计算子串哈希值的效率
  <a class="anchor" href="#%e6%8f%90%e9%ab%98%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95%e8%ae%a1%e7%ae%97%e5%ad%90%e4%b8%b2%e5%93%88%e5%b8%8c%e5%80%bc%e7%9a%84%e6%95%88%e7%8e%87">#</a>
</h3>
<p>怎样设计哈希算法，假设要匹配的字符串的字符集中只包含 K 个字符，可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子
串的哈希值。</p>
<p>比如要处理的字符串只包含 <code>a～z</code> 这 26 个小写字母，那就用二十六进制来表示一个字符串。把 <code>a～z</code> 这 26 个字符映射到 <code>0～25</code> 这 26 个数
字，a 就表示 0，b 就表示 1，以此类推，z 表示 25。</p>
<p>RK 算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。第一部分，可以通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有
子串的哈希值了，所以这部分的时间复杂度是 <code>O(n)</code>。</p>
<p>模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 <code>O(1)</code>，总共需要比较 n-m+1 个子串的哈希值，所以，这部分的时间复杂度也是 <code>O(n)</code>。
所以，RK 算法整体的时间复杂度就是 <code>O(n)</code>。</p>
<p>当存在哈希冲突的时候，有可能存在这样的情况，子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。</p>
<p>解决方法很简单。当发现一个子串的哈希值跟模式串的哈希值相等的时候，只需要再对比一下子串和模式串本身就好了。</p>
<p>哈希算法的冲突概率要相对控制得低一些，如果存在大量冲突，就会导致 RK 算法的时间复杂度退化，效率下降。</p>
<h2 id="bm-算法">
  BM 算法
  <a class="anchor" href="#bm-%e7%ae%97%e6%b3%95">#</a>
</h2>
<p><img src="../../images/bm1.jpg" alt="bm1" /></p>
<p>上面的例子，模式串中不包含 c，所以，模式串向后滑动时，只要 c 与模式串有重合，肯定不匹配。所以，把模式串往后多滑动几位，把模式串移动
到 c 的后面。</p>
<p><img src="../../images/bm2.jpg" alt="bm2" /></p>
<p>当遇到不匹配的字符时，有什么固定的规律，往后多滑动几位？BM 算法，就是在寻找这种规律。</p>
<p>BM 算法包含两部分：</p>
<ul>
<li>坏字符规则（bad character rule）</li>
<li>好后缀规则（good suffix shift）。</li>
</ul>
<h3 id="坏字符规则">
  坏字符规则
  <a class="anchor" href="#%e5%9d%8f%e5%ad%97%e7%ac%a6%e8%a7%84%e5%88%99">#</a>
</h3>
<p>BM 算法的匹配顺序比较特别，它是按照模式串下标从大到小的顺序，倒着匹配的。</p>
<p><img src="../../images/bm3.jpg" alt="bm3" /></p>
<p>从模式串的末尾往前倒着匹配，当发现某个字符没法匹配的时候。把这个没有匹配的字符叫作<strong>坏字符</strong>（主串中的字符），上面的 c 就是是坏字符。
并且 c 并不在模式串中，那么可以直接将模式串移动到 c 的后面，再继续比较。这个时候模式串 &ldquo;abd&rdquo; 和 &ldquo;aca&rdquo; 比较， a 就是坏字符，但是
模式串中下标是 0 的位置是字符 a，只需要往后滑动两位，两个 a 对齐，再继续比较。</p>
<p><img src="../../images/bm4.jpg" alt="bm4" /></p>
<p>如何寻找滑动的规律？</p>
<p>发生不匹配的时，把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，把这个坏字符在模式串中的下标记作 xi。如果不存在，把 xi 
记作 -1。那模式串往后移动的位数就等于 si-xi。（注意，这里的下标，都是字符在模式串的下标）。<strong>如果坏字符在模式串里多处出现，在计
算 xi 的时候，选择最靠后的那个位置的下标。</strong> 避免可能匹配的情况被滑动略过。</p>
<p>BM 算法在最好情况下的时间复杂度非常低，是 <code>O(n/m)</code>。比如，主串是 &ldquo;aaabaaabaaabaaab&rdquo;，模式串是 &ldquo;aaaa&rdquo;。每次比对，模式串都可以直
接后移四位。</p>
<p>单纯使用坏字符规则还是不够的。因为根据 si-xi 计算出来的移动位数，有可能是负数，比如主串是 &ldquo;aaaaaaaaaaaaaaaa&rdquo;，模式串是 &ldquo;baaa&rdquo;。不但
不会向后滑动模式串，还有可能倒退。</p>
<h3 id="好后缀规则">
  好后缀规则
  <a class="anchor" href="#%e5%a5%bd%e5%90%8e%e7%bc%80%e8%a7%84%e5%88%99">#</a>
</h3>
<p>好后缀规则跟坏字符规则的思路类似。</p>
<p><img src="../../images/bm5.jpg" alt="bm5" /></p>
<p>已经匹配的 bc 叫作<strong>好后缀</strong>，记作 <code>{u}</code>。拿它在模式串中查找，如果找到了另一个跟 <code>{u}</code> 相匹配的子串 <code>{u*}</code>，那就将模式串滑动
到子串 <code>{u*}</code> 与主串中 <code>{u}</code> 对齐的位置。</p>
<p>如果在模式串中找不到另一个等于 <code>{u}</code> 的子串，就直接将模式串，滑动到主串中 <code>{u}</code> 的后面。但是有时候不能直接滑动到 <code>{u}</code> 的后面，比如：</p>
<p><img src="../../images/bm6.jpg" alt="bm6" /></p>
<p>针对这种情况，不仅要看好后缀在模式串中，是否有另一个匹配的子串，还要检查好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。</p>
<h3 id="bm-算法实现">
  BM 算法实现
  <a class="anchor" href="#bm-%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0">#</a>
</h3>
<p>当模式串和主串中的某个字符不匹配的时候，选择坏字符规则还是好后缀规则？</p>
<p>分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数。这种处理方法还可以避免前面提到的，根据坏字符规则，
计算得到的往后滑动的位数，有可能是负数的情况。</p>
<p>遇到坏字符时，要计算往后移动的位数 si-xi，如何求得 xi？如果在模式串中顺序遍历查找，就会比较低效。更加高效的方式是使用散列表。</p>
<p>将模式串中的每个字符及其下标都存到散列表中。这样就可以快速找到坏字符在模式串的位置下标了。</p>
<p>实现一种最简单的情况，假设字符串的字符集不是很大，每个字符长度是 1 字节，用大小为 256 的数组，来记录每个字符在模式串中出现的位置。数组的
下标对应字符的 ASCII 码值，数组中存储这个字符在模式串中出现的位置。</p>
<p><img src="../../images/bm7.jpg" alt="bm7" /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">generateBC</span>(<span style="color:#a6e22e">pattern</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">int</span> {

	<span style="color:#a6e22e">bc</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">256</span>)

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">bc</span> {
		<span style="color:#a6e22e">bc</span>[<span style="color:#a6e22e">index</span>] = <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
	}

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">char</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pattern</span> {
		<span style="color:#a6e22e">bc</span>[int(<span style="color:#a6e22e">char</span>)] = <span style="color:#a6e22e">index</span> <span style="color:#75715e">// int(char) 计算 char 的 ASCII 值
</span><span style="color:#75715e"></span>	}

	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">bc</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bm</span>(<span style="color:#a6e22e">main</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">pattern</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#a6e22e">bc</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">generateBC</span>(<span style="color:#a6e22e">pattern</span>)
}
</code></pre></div><h2 id="kmp-算法">
  KMP 算法
  <a class="anchor" href="#kmp-%e7%ae%97%e6%b3%95">#</a>
</h2>
<p>KMP （Knuth Morris Pratt）算法核心思想和 BM 算法类似。区别是 KMP 算法的两部分是：</p>
<ul>
<li>坏字符</li>
<li>好前缀</li>
</ul>
<p>坏字符仍然是不能匹配的那个字符。已经匹配的那段字符串叫作<strong>好前缀</strong>。</p>
<p><img src="../../images/kmp1.jpg" alt="" /></p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/shipengqi/algorithm-learn/commit/f0affa43a408758a4a1a44d5288e6e0087d8415f" title='Last modified by shipengqi | June 18, 2020' target="_blank" rel="noopener">
      <img src="/algorithm-learn/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>June 18, 2020</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/shipengqi/algorithm-learn/edit/master/content//docs/16_string_match_algo.md" target="_blank" rel="noopener">
      <img src="/algorithm-learn/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>

</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#bf-算法">BF 算法</a></li>
    <li><a href="#rk-算法">RK 算法</a>
      <ul>
        <li><a href="#提高哈希算法计算子串哈希值的效率">提高哈希算法计算子串哈希值的效率</a></li>
      </ul>
    </li>
    <li><a href="#bm-算法">BM 算法</a>
      <ul>
        <li><a href="#坏字符规则">坏字符规则</a></li>
        <li><a href="#好后缀规则">好后缀规则</a></li>
        <li><a href="#bm-算法实现">BM 算法实现</a></li>
      </ul>
    </li>
    <li><a href="#kmp-算法">KMP 算法</a></li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












