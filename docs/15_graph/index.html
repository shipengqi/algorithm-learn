<!DOCTYPE html>
<html lang="en" dir=>

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="图#图也是一种非线性表数据结构，比树更复杂。涉及图的算法有很多，也非常复杂，比如图的搜索、最短路径、最小生成树、二 分图等等。
树中的元素称为节点，图中的元素叫作顶点（vertex）。
图中的一个顶点可以与任意其他顶点建立连接关系。这种建立的关系叫作边（edge）。
生活中就有很多符合图这种结构的例子。比如，社交网络，就是一个非常典型的图结构。拿微信举例子。可以把每个用户看作一个顶点。如果两个用户之间互加 好友，那就在两者之间建立一条边。所以，整个微信的好友关系就可以用一张图来表示。每个用户有多少个好友，对应到图中，就叫作顶点的度（degree）， 就是跟顶点相连接的边的条数。
微博的社交关系比微信更复杂一点。微博允许单向关注，也就是说，用户 A 关注了用户 B，但用户 B 可以不关注用户 A。就要引入边的“方向”的概念。
这种边有方向的图叫作有向图。边没有方向的图就叫作无向图。
无向图中有“度”这个概念，表示一个顶点有多少条边。在有向图中，把度分为入度（In-degree）和出度（Out-degree）。
顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。
QQ 中的社交关系要还更复杂。QQ 不仅记录了用户之间的好友关系，还记录了两个用户之间的亲密度，如果两个用户经常往来，那亲密度就比较高；如果不经 常往来，亲密度就比较低。
这里就要用到另一种图，带权图（weighted graph）。在带权图中，每条边都有一个权重（weight），可以通过这个权重来表示 QQ 好友 间的亲密度。
图的存储#邻接矩阵#邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，就将 A[i][j] 和 A[j][i] 标记为 1； 对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那就将 A[i][j] 标记为 1。同理，如果有一条箭 头从顶点 j 指向顶点 i 的边，就将 A[j][i] 标记为 1。对于带权图，数组中就存储相应的权重。
邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。
如果存储的是稀疏图（Sparse Matrix），也就是说，顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。比如微信有好几亿的 用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。如果用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。
邻接表#邻接表有点像散列表，每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。图中画的是一个有向图的邻接表存储方式，每个顶点对应的 链表里面，存储的是指向的顶点。对于无向图来说，也是类似的，不过，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点。">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="图" />
<meta property="og:description" content="图#图也是一种非线性表数据结构，比树更复杂。涉及图的算法有很多，也非常复杂，比如图的搜索、最短路径、最小生成树、二 分图等等。
树中的元素称为节点，图中的元素叫作顶点（vertex）。
图中的一个顶点可以与任意其他顶点建立连接关系。这种建立的关系叫作边（edge）。
生活中就有很多符合图这种结构的例子。比如，社交网络，就是一个非常典型的图结构。拿微信举例子。可以把每个用户看作一个顶点。如果两个用户之间互加 好友，那就在两者之间建立一条边。所以，整个微信的好友关系就可以用一张图来表示。每个用户有多少个好友，对应到图中，就叫作顶点的度（degree）， 就是跟顶点相连接的边的条数。
微博的社交关系比微信更复杂一点。微博允许单向关注，也就是说，用户 A 关注了用户 B，但用户 B 可以不关注用户 A。就要引入边的“方向”的概念。
这种边有方向的图叫作有向图。边没有方向的图就叫作无向图。
无向图中有“度”这个概念，表示一个顶点有多少条边。在有向图中，把度分为入度（In-degree）和出度（Out-degree）。
顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。
QQ 中的社交关系要还更复杂。QQ 不仅记录了用户之间的好友关系，还记录了两个用户之间的亲密度，如果两个用户经常往来，那亲密度就比较高；如果不经 常往来，亲密度就比较低。
这里就要用到另一种图，带权图（weighted graph）。在带权图中，每条边都有一个权重（weight），可以通过这个权重来表示 QQ 好友 间的亲密度。
图的存储#邻接矩阵#邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，就将 A[i][j] 和 A[j][i] 标记为 1； 对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那就将 A[i][j] 标记为 1。同理，如果有一条箭 头从顶点 j 指向顶点 i 的边，就将 A[j][i] 标记为 1。对于带权图，数组中就存储相应的权重。
邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。
如果存储的是稀疏图（Sparse Matrix），也就是说，顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。比如微信有好几亿的 用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。如果用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。
邻接表#邻接表有点像散列表，每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。图中画的是一个有向图的邻接表存储方式，每个顶点对应的 链表里面，存储的是指向的顶点。对于无向图来说，也是类似的，不过，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://shipengqi.github.io/algorithm-learn/docs/15_graph/" />
<meta property="article:modified_time" content="2020-06-18T17:06:12+08:00" />
<title>图 | Algorithm Learning</title>
<link rel="manifest" href="/algorithm-learn/manifest.json">
<link rel="icon" href="/algorithm-learn/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/algorithm-learn/book.min.b3215d9d1d18d9051e7fbe8f256ff80e30f41d29073b86348e230d297b771002.css" integrity="sha256-syFdnR0Y2QUef76PJW/4DjD0HSkHO4Y0jiMNKXt3EAI=">
<script defer src="/algorithm-learn/en.search.min.511cae842a1aa3c6a84d63e20bade0ff9213702b34b6fe826804dc6e1b02a9e3.js" integrity="sha256-URyuhCoao8aoTWPiC63g/5ITcCs0tv6CaATcbhsCqeM="></script>

<script defer src="/algorithm-learn/sw.min.eaff391435f87073ec5af42687d96b565bbf32cc51b0c17648cd12c7d96f6307.js" integrity="sha256-6v85FDX4cHPsWvQmh9lrVlu/MsxRsMF2SM0Sx9lvYwc="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir=>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/algorithm-learn"><span>Algorithm Learning</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>






  
<ul>
  
  <li>
    <a href="https://github.com/shipengqi/algorithm-learn" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://shipengqi.github.io/" target="_blank" rel="noopener">
        Blog
      </a>
  </li>
  
</ul>







  <p>━━━━━━━━━━━━━━━━━━━━</p>
<ul>
<li><a href="/algorithm-learn/docs/01_complex_analysis/">复杂度分析</a></li>
<li><a href="/algorithm-learn/docs/02_array/">数组</a></li>
<li><a href="/algorithm-learn/docs/03_link_list/">链表</a></li>
<li><a href="/algorithm-learn/docs/04_stack/">栈</a></li>
<li><a href="/algorithm-learn/docs/05_queue/">队列</a></li>
<li><a href="/algorithm-learn/docs/06_recursion/">递归</a></li>
<li><a href="/algorithm-learn/docs/07_sort/">排序</a></li>
<li><a href="/algorithm-learn/docs/08_linear_sort/">线性排序</a></li>
<li><a href="/algorithm-learn/docs/09_binary_search/">二分查找</a></li>
<li><a href="/algorithm-learn/docs/10_skip_list/">跳表</a></li>
<li><a href="/algorithm-learn/docs/11_hash_table/">散列表</a></li>
<li><a href="/algorithm-learn/docs/12_hash_algo/">哈希算法</a></li>
<li><a href="/algorithm-learn/docs/13_binary_tree/">二叉树</a></li>
<li><a href="/algorithm-learn/docs/14_heap/">堆</a></li>
<li><a href="/algorithm-learn/docs/15_graph/"class=active>图</a></li>
<li><a href="/algorithm-learn/docs/16_string_match_algo/">字符串匹配算法</a></li>
<li><a href="/algorithm-learn/docs/17_trie/">Trie 树</a></li>
<li><a href="/algorithm-learn/docs/18_ac/">AC 自动机</a></li>
<li><a href="/algorithm-learn/docs/19_greedy/">贪心算法</a></li>
<li><a href="/algorithm-learn/docs/20_deivide_conquer/">分治算法</a></li>
<li><a href="/algorithm-learn/docs/21_backtracking/">回溯算法</a></li>
<li><a href="/algorithm-learn/docs/22_dynamic_programming/">动态规划</a></li>
<li><a href="/algorithm-learn/docs/23_bit_map/">位图</a></li>
<li><a href="/algorithm-learn/docs/24_bmore_tree/">索引</a></li>
<li><a href="/algorithm-learn/docs/25_vector/">向量空间</a>
<!-- raw HTML omitted --></li>
</ul>










</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/algorithm-learn/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>图</strong>

  <label for="toc-control">
    
    <img src="/algorithm-learn/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#图的存储">图的存储</a>
      <ul>
        <li><a href="#邻接矩阵">邻接矩阵</a></li>
        <li><a href="#邻接表">邻接表</a></li>
      </ul>
    </li>
    <li><a href="#深度和广度优先搜索">深度和广度优先搜索</a>
      <ul>
        <li><a href="#广度优先搜索">广度优先搜索</a></li>
        <li><a href="#深度优先搜索">深度优先搜索</a></li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="图">
  图
  <a class="anchor" href="#%e5%9b%be">#</a>
</h1>
<p>图也是一种非线性表数据结构，比树更复杂。涉及图的算法有很多，也非常复杂，比如图的搜索、最短路径、最小生成树、二
分图等等。</p>
<p>树中的元素称为节点，图中的元素叫作<strong>顶点</strong>（vertex）。</p>
<p><img src="../../images/graph1.jpg" alt="graph1" />
图中的一个顶点可以与任意其他顶点建立连接关系。这种建立的关系叫作<strong>边</strong>（edge）。</p>
<p>生活中就有很多符合图这种结构的例子。比如，社交网络，就是一个非常典型的图结构。拿微信举例子。可以把每个用户看作一个顶点。如果两个用户之间互加
好友，那就在两者之间建立一条边。所以，整个微信的好友关系就可以用一张图来表示。每个用户有多少个好友，对应到图中，就叫作顶点的<strong>度</strong>（degree），
就是跟顶点相连接的边的条数。</p>
<p>微博的社交关系比微信更复杂一点。微博允许单向关注，也就是说，用户 A 关注了用户 B，但用户 B 可以不关注用户 A。就要引入边的“方向”的概念。</p>
<p><img src="../../images/graph2.jpg" alt="graph2" /></p>
<p>这种边有方向的图叫作<strong>有向图</strong>。边没有方向的图就叫作<strong>无向图</strong>。</p>
<p>无向图中有“度”这个概念，表示一个顶点有多少条边。在有向图中，把度分为<strong>入度</strong>（In-degree）和<strong>出度</strong>（Out-degree）。</p>
<p>顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。</p>
<p>QQ 中的社交关系要还更复杂。QQ 不仅记录了用户之间的好友关系，还记录了两个用户之间的亲密度，如果两个用户经常往来，那亲密度就比较高；如果不经
常往来，亲密度就比较低。</p>
<p>这里就要用到另一种图，<strong>带权图</strong>（weighted graph）。在带权图中，每条边都有一个<strong>权重</strong>（weight），可以通过这个权重来表示 QQ 好友
间的亲密度。</p>
<p><img src="../../images/graph3.jpg" alt="graph3" /></p>
<h2 id="图的存储">
  图的存储
  <a class="anchor" href="#%e5%9b%be%e7%9a%84%e5%ad%98%e5%82%a8">#</a>
</h2>
<h3 id="邻接矩阵">
  邻接矩阵
  <a class="anchor" href="#%e9%82%bb%e6%8e%a5%e7%9f%a9%e9%98%b5">#</a>
</h3>
<p>邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，就将 <code>A[i][j]</code> 和 <code>A[j][i]</code> 标记为 1；
对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那就将 <code>A[i][j]</code> 标记为 1。同理，如果有一条箭
头从顶点 j 指向顶点 i 的边，就将 <code>A[j][i]</code> 标记为 1。对于带权图，数组中就存储相应的权重。</p>
<p><img src="../../images/graph4.jpg" alt="graph4" /></p>
<p>邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。</p>
<p>如果存储的是稀疏图（Sparse Matrix），也就是说，顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。比如微信有好几亿的
用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。如果用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。</p>
<h3 id="邻接表">
  邻接表
  <a class="anchor" href="#%e9%82%bb%e6%8e%a5%e8%a1%a8">#</a>
</h3>
<p><img src="../../images/graph5.jpg" alt="graph5" /></p>
<p>邻接表有点像散列表，每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。图中画的是一个有向图的邻接表存储方式，每个顶点对应的
链表里面，存储的是指向的顶点。对于无向图来说，也是类似的，不过，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点。</p>
<p>邻接表存储起来比较节省空间，但是使用起来就比较耗时间。</p>
<p>比如上图中，如果要确定，是否存在一条从顶点 2 到顶点 4 的边，就要遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4。而且，链表的存储方式
对缓存不友好。所以，比起邻接矩阵的存储方式，在邻接表中查询两个顶点之间的关系就没那么高效了。</p>
<p>在基于链表法解决冲突的散列表中，如果链过长，为了提高查找效率，可以将链表换成其他更加高效的数据结构，比如平衡二叉查找树等。邻接表长得很像散列。
所以，也可以将邻接表同散列表一样进行“改进升级”。</p>
<p>可以将邻接表中的链表改成平衡二叉查找树。实际开发中，可以选择用红黑树。这样，就可以更加快速地查找两个顶点之间是否存在边了。当然，这里的二叉
查找树可以换成其他动态数据结构，比如跳表、散列表等。除此之外，还可以将链表改成有序动态数组，可以通过二分查找的方法来快速定位两
个顶点之间否是存在边。</p>
<h4 id="逆邻接表">
  逆邻接表
  <a class="anchor" href="#%e9%80%86%e9%82%bb%e6%8e%a5%e8%a1%a8">#</a>
</h4>
<p>用一个邻接表来存储这种有向图有时候是不够的。比如微博中去查找某个用户关注了哪些用户非常容易，但是如果要想知道某个用户都被哪些用户关注了，也就
是用户的粉丝列表，是非常困难的。</p>
<p>需要一个逆邻接表。邻接表中存储了用户的关注关系，逆邻接表中存储的是用户的被关注关系。</p>
<p><img src="../../images/graph6.jpg" alt="graph6" /></p>
<h2 id="深度和广度优先搜索">
  深度和广度优先搜索
  <a class="anchor" href="#%e6%b7%b1%e5%ba%a6%e5%92%8c%e5%b9%bf%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2">#</a>
</h2>
<p>在社交网络中，有一个六度分割理论，具体是说，你与世界上的另一个人间隔的关系不会超过六度，也就是说平均只需要六步就可以联系到任何两个互不相识的人。
一个用户的一度连接用户很好理解，就是他的好友，二度连接用户就是他好友的好友，三度连接用户就是他好友的好友的好友。在社交网络中，往往通过用户之
间的连接关系，来实现推荐“可能认识的人”这么一个功能。</p>
<p>如何找出一个用户的所有三度（其中包含一度、二度和三度）好友关系？</p>
<h3 id="广度优先搜索">
  广度优先搜索
  <a class="anchor" href="#%e5%b9%bf%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2">#</a>
</h3>
<p>广度优先搜索（Breadth-First-Search），简称为 BFS。其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，
依次往外搜索。</p>
<p><img src="../../images/graph_bsf.jpg" alt="graph_bsf" /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// s 起始顶点，t 终止顶点
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Graph</span>) <span style="color:#a6e22e">BFS</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">t</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">t</span> {
		<span style="color:#66d9ef">return</span>
	}

	<span style="color:#75715e">// init prev 记录搜索路径
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">prev</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">v</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">prev</span> {
		<span style="color:#a6e22e">prev</span>[<span style="color:#a6e22e">index</span>] = <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
	}

	<span style="color:#75715e">// search by queue
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">queue</span> []<span style="color:#66d9ef">int</span> <span style="color:#75715e">// 一个队列，存储已经被访问、但相连的顶点还没有被访问的顶点
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">visited</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">v</span>) <span style="color:#75715e">// 记录已经被访问的顶点，避免顶点被重复访问
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">queue</span> = append(<span style="color:#a6e22e">queue</span>, <span style="color:#a6e22e">s</span>)
	<span style="color:#a6e22e">visited</span>[<span style="color:#a6e22e">s</span>] = <span style="color:#66d9ef">true</span>  <span style="color:#75715e">// 顶点设置为 true 表示已经被访问
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">isFound</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">false</span>
	<span style="color:#66d9ef">for</span> len(<span style="color:#a6e22e">queue</span>) &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> !<span style="color:#a6e22e">isFound</span> {
		<span style="color:#a6e22e">top</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">queue</span>[<span style="color:#ae81ff">0</span>]
		<span style="color:#a6e22e">queue</span> = <span style="color:#a6e22e">queue</span>[<span style="color:#ae81ff">1</span>:]
		<span style="color:#a6e22e">linkedList</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">adj</span>[<span style="color:#a6e22e">top</span>]
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">linkedList</span>.<span style="color:#a6e22e">Front</span>(); <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>; <span style="color:#a6e22e">e</span> = <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Next</span>() {
			<span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Value</span>.(<span style="color:#66d9ef">int</span>)
			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">visited</span>[<span style="color:#a6e22e">k</span>] {
				<span style="color:#a6e22e">prev</span>[<span style="color:#a6e22e">k</span>] = <span style="color:#a6e22e">top</span>
				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">t</span> {
					<span style="color:#a6e22e">isFound</span> = <span style="color:#66d9ef">true</span>
					<span style="color:#66d9ef">break</span>
				}
				<span style="color:#a6e22e">queue</span> = append(<span style="color:#a6e22e">queue</span>, <span style="color:#a6e22e">k</span>)
				<span style="color:#a6e22e">visited</span>[<span style="color:#a6e22e">k</span>] = <span style="color:#66d9ef">true</span>
			}
		}
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">isFound</span> {
		<span style="color:#a6e22e">printPrev</span>(<span style="color:#a6e22e">prev</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">t</span>)
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;no path found from %d to %d\n&#34;</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">t</span>)
	}
}
</code></pre></div><p><code>prev</code> 用来记录搜索路径。当从顶点 s 开始，广度优先搜索到顶点 t 后，<code>prev</code> 数组中存储的就是搜索的路径。不过，这个路径是反向存储的。
<code>prev[w]</code> 存储的是，顶点 w 是从哪个前驱顶点遍历过来的。比如，我们通过顶点 2 的邻接表访问到顶点 3，那 <code>prev[3]</code> 就等于 2。为了正
向打印出路径，需要递归地来打印 <code>printPrev</code>。</p>
<p><img src="../../images/graph_bsf1.jpg" alt="graph_bsf1" />
<img src="../../images/graph_bsf2.jpg" alt="graph_bsf2" />
<img src="../../images/graph_bsf3.jpg" alt="graph_bsf3" /></p>
<h4 id="广度优先搜索的时间空间复杂度">
  广度优先搜索的时间、空间复杂度
  <a class="anchor" href="#%e5%b9%bf%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2%e7%9a%84%e6%97%b6%e9%97%b4%e7%a9%ba%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6">#</a>
</h4>
<p>最坏情况下，终止顶点 t 离起始顶点 s 很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，
广度优先搜索的时间复杂度是 <code>O(V+E)</code>，其中，V 表示顶点的个数，E 表示边的个数。当然，对于一个连通图来说，也就是说一个图中的所有顶点都
是连通的，E 肯定要大于等于 <code>V-1</code>，所以，广度优先搜索的时间复杂度也可以简写为 <code>O(E)</code>。</p>
<p>广度优先搜索的空间消耗主要在几个辅助变量 <code>visited</code> 数组、<code>queue</code> 队列、<code>prev</code> 数组上。这三个存储空间的大小都不会超过顶点的个数，
所以空间复杂度是 <code>O(V</code>)。</p>
<h3 id="深度优先搜索">
  深度优先搜索
  <a class="anchor" href="#%e6%b7%b1%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2">#</a>
</h3>
<p>深度优先搜索（Depth-First-Search），简称 DFS。
假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，
直到最终找到出口。这种走法就是一种<strong>深度优先搜索策略</strong>。</p>
<p><img src="../../images/graph_dsf.jpg" alt="graph_dsf" /></p>
<p>图中寻找一条从顶点 s 到顶点 t 的路径，s 就可以理解为迷宫中起始的位置，t 代表出口。</p>
<p>深度优先搜索找到的并不是顶点 s 到顶点 t 的最短路径。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Graph</span>) <span style="color:#a6e22e">DSF</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">t</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">t</span> {
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#75715e">// init prev 记录搜索路径
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">prev</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">v</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">prev</span> {
		<span style="color:#a6e22e">prev</span>[<span style="color:#a6e22e">index</span>] = <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
	}

	<span style="color:#a6e22e">visited</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">v</span>) <span style="color:#75715e">// 记录已经被访问的顶点，避免顶点被重复访问
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">visited</span>[<span style="color:#a6e22e">s</span>] = <span style="color:#66d9ef">true</span>  <span style="color:#75715e">// 顶点设置为 true 表示已经被访问
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">recurse</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">prev</span>, <span style="color:#a6e22e">visited</span>, <span style="color:#66d9ef">false</span>)

	<span style="color:#a6e22e">printPrev</span>(<span style="color:#a6e22e">prev</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">t</span>)
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Graph</span>) <span style="color:#a6e22e">recurse</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">t</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">prev</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">visited</span> []<span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">isFound</span> <span style="color:#66d9ef">bool</span>) {

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">isFound</span> {
		<span style="color:#66d9ef">return</span>
	}

	<span style="color:#a6e22e">visited</span>[<span style="color:#a6e22e">s</span>] = <span style="color:#66d9ef">true</span>

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">t</span> {
		<span style="color:#a6e22e">isFound</span> = <span style="color:#66d9ef">true</span>
		<span style="color:#66d9ef">return</span>
	}

	<span style="color:#a6e22e">linkedList</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">adj</span>[<span style="color:#a6e22e">s</span>]
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">linkedList</span>.<span style="color:#a6e22e">Front</span>(); <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>; <span style="color:#a6e22e">e</span> = <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Next</span>() {
		<span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Value</span>.(<span style="color:#66d9ef">int</span>)
		<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">visited</span>[<span style="color:#a6e22e">k</span>] {
			<span style="color:#a6e22e">prev</span>[<span style="color:#a6e22e">k</span>] = <span style="color:#a6e22e">s</span>
			<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">recurse</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">prev</span>, <span style="color:#a6e22e">visited</span>, <span style="color:#66d9ef">false</span>)
		}
	}

}
</code></pre></div><h4 id="深度度优先搜索的时空间间复杂度">
  深度度优先搜索的时、空间间复杂度
  <a class="anchor" href="#%e6%b7%b1%e5%ba%a6%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2%e7%9a%84%e6%97%b6%e7%a9%ba%e9%97%b4%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6">#</a>
</h4>
<p>从图可以看出，每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的时间复杂度是 <code>O(E)</code>，E 表示边的个数。</p>
<p>深度优先搜索算法的消耗内存主要是 visited、prev 数组和递归调用栈。visited、prev 数组的大小跟顶点的个数 V 成正比，递归调用栈的最
大深度不会超过顶点的个数，所以总的空间复杂度就是 <code>O(V)</code>。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/shipengqi/algorithm-learn/commit/f0affa43a408758a4a1a44d5288e6e0087d8415f" title='Last modified by shipengqi | June 18, 2020' target="_blank" rel="noopener">
      <img src="/algorithm-learn/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>June 18, 2020</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/shipengqi/algorithm-learn/edit/master/content//docs/15_graph.md" target="_blank" rel="noopener">
      <img src="/algorithm-learn/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>

</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#图的存储">图的存储</a>
      <ul>
        <li><a href="#邻接矩阵">邻接矩阵</a></li>
        <li><a href="#邻接表">邻接表</a></li>
      </ul>
    </li>
    <li><a href="#深度和广度优先搜索">深度和广度优先搜索</a>
      <ul>
        <li><a href="#广度优先搜索">广度优先搜索</a></li>
        <li><a href="#深度优先搜索">深度优先搜索</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












